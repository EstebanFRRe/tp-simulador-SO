PSEUDOCODIGO //para mandarle al chat que traduszca todo a python
AMBIENTE
	
  registro= registro de
  	ID: entero                    //ID del proceso
    TAM: entero                   //tamaño  
    TA: entero                     //Tiempo de arribo
    TI: entero                    //Tiempo de irrupcion
  Fin registro
	Archivo: Archivo de reg 				//Archivo de entrada en formato csv
  reg: registro

  Memoria = [mem] # Estado de la memoria
  Entrada = [procesos] # lista de procesos de entrada
  Nuevos = [procesos] # Listas de nuevos
  Listos = [procesos] # Cola de listos
  ListoySuspendidos = [procesos] # lista de procesos listos y suspendidos
  Terminados = [procesos] # lista de procesos terminados
  
  procesos = registro de           //Registro para cada proceso de las diferentes listas (Entrada, Nuevos, Listos/suspendidos, Listos, Terminados)
    ID: entero
    TA: entero 										//Tiempo de arribo
    TI: entero 										//Tiempo de irrupcion
    TAM: entero										//Tamaño de proceso
    ESTADO: ("Nuevo", "Listo", "Listo y suspendido", "Ejecutando", "Terminado")
    TF: entero  									//Tiempo de finalizacion
    TM: entero 										//Tiempo de ingreso a memoria principal   (TF y TM para calculo de tiempo de espera y eso)
    TE: entero										//Tiempo de espera del proceso (Tiempo en cola de listos)
    TR: entero 										//Tiempo de retorno del proceso  (Tiempo entre listos y ejecucion)
    prox: puntero a procesos
    ant: puntero a procesos
  Fin registro

  primE, primN, primL, primLS, primT, ultE, ultN, ultL, ultLS, ultT, E1,E2, N1,N2 , L1, L2, LS1, LS2, T1, T2: puntero a procesos //No me acuerdo como funcionaba exactamente el pseudo pero pongo un prim y un puntero para cada lista segun su letra inicial 

  mem = registro de 							//Lista para facilitar muestra de tabla de memoria
    particion: (0,1,2,3)						  //id
    dir_inicio: entero
    tamaño:(250, 150, 50, 100)
    contenido: AN(30)          //Proceso que tiene asignado o sistema operativo
    fragmentacion: entero
    prox: puntero a mem
    ant: puntero a mem
  Fin registro

  primM, ult1, M: puntero a mem
  
  
  Procedimiento Cargar_entrada(primX,ultX:puntero a procesos)       //Cargamos la lista de entrada con los procesos del archivo ordenando segun tiempo de arribo de menor a mayor
  AMBIENTE
    X1: puntero a procesos
    X2: puntero a procesos
  Accion    
    Abrir (Arch)
    Leer(Arch,reg)
    Mientras NFDA(Arch) hacer
      Nuevo X1                                  //Puntero nuevo a agregar
      X2:= primX
      X1.ID:= reg.ID
      X1.TA:= reg.TA
      X1.TI:= reg.TI
      X1.TAM:= reg.TAM
      X1.ESTADO:= "Nuevo"    
      X1.TF:= 0             
      X1.TM:= 0                       
      X1.TE:= 0             
      X1.TR:= 0             

      Si primX = Nil entonces      //Si la lista esta vacia se carga en primer u ultimo lugar el proceso
        primX:= X1
        ult.X:= X1
        X1.prox:= nil
        X1.ant:= nil     
      Sino                                  //Si la lista no esta vacia entonces hacemos la comparacion
        Mientras X1.TA > X2.TA y X2 <> nil entonces     //Recorremos la lista comparando segun el TA de menor a mayor 
          X1.ant:= X2
          X2:= X2.prox
        Fin mientras
        Si X2 <> nil entonces               //Si no llegamos al final de la lista entonces trabajamos al principio o en el medio
          Si X1.TA = X2.TA entonces         //Si los TA son iguales, el proceso que esta en memoria tiene prioridad(X2) y cargamos a su derecha el proceso entrante(X1)
            X1.prox:= X2.prox
            X1.ant:= X2
            X2.prox.ant:= X1
            X2.prox:= X1
            Si X2 = ultX entonces           //Como cargamos a derecha de X2 entonces no es necesario pregunbtar si X2 es prim, pq no va a variar
              ultX:= X1
            Fin si
          Sino
            X1.prox:= X2                    //Si el TA de X1(proceso a cargar) es menor entonces lo cargamos a izquierda de X2(proceso existente)
            X1.ant:= X2.ant
            X2.ant.prox:= X1
            X2.ant:= X1
            Si X2 = primX entonces          //Como cargamos a izquierda de X2 entonces no es necesario pregunbtar si X2 es ult, pq no va a variar
              primX:= X1
            Fin si
          Fin si
        Sino
          ultX.prox:= X1
          X1.ant:= ultX.ant
          ultX:= X1
        Fin si
      Fin si
      Leer(Arch)
    Fin mientras
    Cerrar(Arch)
  Fin procedimiento



  Procedimiento Cargar_procesos en lista(primX,ultX, Y: puntero a procesos; estado: ("Nuevo", "Listo", "Listo y suspendido", "Ejecutando", "Terminado")) //Estado cambia segun la lista, lo demas se mantiene
   	 														              //Cargamos procdimiento en lista a partir de otra lista
  AMBIENTE
    X1: puntero a procesos
    X2: puntero a procesos
  ACCION
    Nuevo X1                                  //Puntero nuevo a agregar
    X2:= primX                                //puntero usado para recorrer la lista y comparar
    X1.ID:= Y.ID                              //Cargamos primeros datos a partir de la lista de la que provienen los procesos (Y puntero que apunta al proceso a cargar)
    X1.TA:= Y.TA
    X1.TI:= Y.TI
    X1.TAM:= Y.TAM
    X1.ESTADO:= estado          
    X1.TF:= Y.TF             
    X1.TM:= Y.TM            
    X1.TE:= Y.TE             
    X1.TR:= Y.TR            
    
    Si primX = Nil entonces      //Si la lista esta vacia se carga en primer u ultimo lugar el proceso
      primX:= X1
      ult.X:= X1
      X1.prox:= nil
      x1.ant:= nil
    Sino                                  //Si la lista no esta vacia entonces hacemos la comparacion
      Mientras X1.TI > X2.TI y X2 <> nil entonces     //Recorremos la lista comparando segun el TI de menor a mayor 
        X1.ant:= X2
        X2:= X2.prox
      Fin mientras
      Si X2 <> nil entonces               //Si no llegamos al final de la lista entonces trabajamos al principio o en el medio
        Si X1.TI = X2.TI entonces         //Si los TI son iguales, el proceso que esta en memoria tiene prioridad(X2) y cargamos a su derecha el proceso entrante(X1)
          X1.prox:= X2.prox
            X1.ant:= X2
            X2.prox.ant:= X1
            X2.prox:= X1
            Si X2 = ultX entonces           //Como cargamos a derecha de X2 entonces no es necesario pregunbtar si X2 es prim, pq no va a variar
              ultX:= X1
            Fin si
          Sino
            X1.prox:= X2                    //Si el TI de X1(proceso a cargar) es menor entonces lo cargamos a izquierda de X2(proceso existente)
            X1.ant:= X2.ant
            X2.ant.prox:= X1
            X2.ant:= X1
            Si X2 = primX entonces          //Como cargamos a izquierda de X2 entonces no es necesario pregunbtar si X2 es ult, pq no va a variar
              primX:= X1
            Fin si
        Fin si
      Sino                                //cargamos al final directamente
        ultX.prox:= X1
        X1.ant:= ultX.ant
        ultX:= X1
      Fin si
    Fin si    
  Fin procedimiento

  Procedimiento Borrar procesos de lista(Y, primX, ultX: puntero a procesos)    //eliminamos proceso de una lista
    Si primX = Y entonces                   //Si era el primer proceso
      primX.= Y.prox
      Y.prox.ant:= nil
      eliminar Y
    Sino
      Si ultX = Y entonces                  //Si era el ultimo
        ultX:= Y.ant
        Y.ant.prox:= nil
        eliminar Y
      Sino
        Y.ant.prox:= Y.prox                 //Si estaba en el medio de la lista
        Y.prox.ant:= Y.ant
        eliminar Y
      Fin si
    Fin si
  Fin procedimiento


  Procedimiento para buscar en las listas 
 
  
  Procedimiento carga_best_fit (X:puntero a procesos) 								//El dato ingresado es el puntero al nodo del cual nos interesa intentar ingresar a memoria principal segun las condiciones impuestas
  	carga_hecha:= falso
    Si X*TAM <= 250 y X*TAM > 0 entonces
      Si (band3 = falso) y (carga_hecha = falso) entonces
        Si *X.TAM <= 50 entonces 																				//Probamos primero con la particion de 50kb, si no puede prueba la de 150, y si no puede prueba la de 250.
          Cargar proceso en lista de listos 														//se carga el proceso en lista de listos
          band3:= true 																									//bandera se vuelve verdadera pq ese espacio de memoria esta ocupado ahora
          carga_hecha:= true 
        Fin si																												
      Fin si
      Si (band2 = falso) y (carga_hecha = falso) entonces								
        Si *X.TAM <= 150 entonces
          Cargar proceso en lista de listos
          band2:= true
          carga_hecha:= true
        Fin si
      Fin si
      Si (band1 = falso) y (carga_hecha = falso) entonces
        Si *X.TAM <= 250 entonces
          Cargar proceso en lista de listos
          band1:= true
          carga_hecha:=true 
        Fin si
      Fin si
    Sino
      Print("El proceso", ID "es demasiado grande para ser ejecutado por lo tanto sera eliminado")
      Procediemiento Borrar procesos de lista
    Fin si
  Fin procedimiento
          
  
  Tiempo_actual: entero  				//para poder calcular si corresponde o no que ingrese el proceso a lista de nuevos / memoria segun su tiempo de arribo.
  multiprogramacion: entero   	//para control de si se alcanzo un grado de multiprogramacion igual a 5 o no.
  Tiempo_Espera_prom: real 	 	// tiempoDeRetorno - TI
  Tiempo_Retorno_prom: real 	// tiempoDeFinalizacion - TM
  Rendimiento: real           // cantidad de trabajos terminados por unidad de tiempo
  cant_proc_E: entero 					//Contador para saber cuantos procesos hay en la lista de entrada y asi poder calcular los promedios (en python capaz no es necesario)
  cant_proc_N: entero 					//contador de procesos para lista de nuevos
  cant_proc_L: entero						//contador de procesos para lista de listos
  cant_proc_LS: entero 					//contador de procesos para lista de listos/suspendidos
  cant_proc_T: entero 			//contador de procesos en lista de terminados para poder calcular la cantidad de procesos que se ejecutaron en cierta cantidad de tiempo, es decir el promedio de trabajos realizados por unid de tiempo
  i: entero 										//controlador de ciclos Manejados por contador
  
  
  finDeCargaMem: logico 		//Bandera para indicar que la verificiacion de multiprogramacion para la carga de procesos esta terminada
  Band: logico  						//Bandera para control de ciclo principal, donde al no quedar mas procesos que trabajar en ninguna lista (excepto de terminados) se termina el ciclo principal.
  Band1: logico 						//Bandera para saber si el Particion 1 tiene un proceso adentro  
  Band2: logico 						//Bandera para saber si el Particion 2 tiene un proceso adentro     
  Band3: logico							//Bandera para saber si el Particion 3 tiene un proceso adentro 
  espacio: entero 					//Esta variable servira como control para determinar cual de las particiones esta libre en memoria principal para tratar de ingresar un proceso de mem.sec al usar el algoritmo best_fit
  retorno_listaN_vacia?: logico //Esta variable sirve para volver a analizar los procesos restantes en caso de que la lista de entrada este vacia
  carga_hecha: logico				//Esta variable nos permite controlar si se pudo realizar la carga de un proceso a memoria principal o no
  
ACCION
	Tiempo_actual:= 1 																			//Inicializacion de variables y contadores
  multiprogramacion:= 0
  band:= falso 																						//bandera que controla el ciclo principal
  band1:= falso 																					//banderas que si son falsas significa que esta vacia la particion
  band2:= falso
  band3:= falso
  finDeCargaMem:= falso
  cant_proc_N:= 0
  cant_proc_L:= 0
  cant_proc_LS:= 0
  cant_proc_T:= 0
  retorno_listaN_vacia?:= falso
  
  Abrir E/S (Archivo) 																		//Abrimos y leemos archivo de entrada
  Leer (Arch,reg)
  
  Mientras NFDA(Arch) hacer 
  	Procedimiento_Cargar procesos en lista de entrada 		//Cargamos lista de entrada, aca usamos la funcion "calculo_best_fit" por ejemplo, y todo lo necesario para cargar los datos de cada proceso
    cant_proc_E:=cant_proc_E + 1.
    Leer(Arch,reg)
  Fin mientras
  
  Procedimiento ordenar lista de entrada por tiempo de arribo 		//Ordenamos lista de entrada
  
  Mientras band = falso hacer
  	Si restorno_lista_vacia? = falso entonces
      Para i:=1 hasta cantidad_procesos hacer  							//controlamos todos los procesos de la lista de entrada para determinar si corresponde su entrada a memoria o no
        E:= PrimE
        Si *E.TA = Tiempo_actual entonces
          Procedimiento_Cargar proceso en lista de nuevos
          Cambiar el estado a nuevo 
           Procedimiento Borrar proceso de lista de entrada
          E:= *E.prox
          cant_proc_E:= cant_proc_E - 1
          cant_porc_N:= cant_proc_N + 1
        fin Si  
      Fin para
    Fin si
    
  	Si primN = nil entonces 															//Si la lista de nuevos esta vacia entonces preguntamos si podemos mover algo de mem secundaria a principal
    	Si cant_proc_L < 3 entonces 												//El orden de prioridad a seguir es que ingresa el proceso de mem secund que haya llegado antes a memoria secundaria. Si el TM es igual para ambos ingresa el de menor TI. Si el TI es igual en ambos procesos entonces entra arbitrariamente 1 de los 2.
        Si primLS <> nil entonces 												//Significa que la cola de listo/suspendido no esta vacia
          LS:= primLS 																		
          Si *LS.prox <> nil entonces 										//Significa que la cola de listo/suspendido tiene 2 procesos por lo que haremos 2 intentos para ingresarlos a memoria principal
            Si *LS.TM < *LS.prox.TM entonces							//Arranca la comparacion entre los 2 procesos
              primLS:= *LS.prox
              carga_best_fit(LS)
              Si carga_hecha = true entonces 							//En caso de que la carga haya sido realizada con exito entonces modificamos los contadores de las respectivas listas y las mismas listas en si eliminando los procesos movidos
              	cant_proc_LS:=cant_proc_LS - 1
        				cant_proc_L:= cant_proc_L + 1
                Borrar proceso de lista de listos/suspendidos
              Fin si
            Sino
              Si *LS.TM > *LS.prox.TM entonces
                carga_best_fit(LS.prox)
                Si carga_hecha = true entonces
              		cant_proc_LS:=cant_proc_LS - 1
        					cant_proc_L:= cant_proc_L + 1
                  Borrar proceso de lista de listos/suspendidos
              	Fin si
              Sino
                Si *LS.TI <= *LS.prox.TI entonces
                  primLS:= *LS.prox
                  carga_best_fit(LS)
                  Si carga_hecha = true entonces
              			cant_proc_LS:=cant_proc_LS - 1
        						cant_proc_L:= cant_proc_L + 1
                    Borrar proceso de lista de listos/suspendidos
              		Fin si
                Sino
                  Si *LS.TM > *LS.prox.TM entonces
                    carga_best_fit(LS.prox)
                    Si carga_hecha = true entonces
              				cant_proc_LS:=cant_proc_LS - 1
        							cant_proc_L:= cant_proc_L + 1
                      Borrar proceso de lista de listos/suspendidos
              			Fin si
                  Fin si
                Fin si
              Fin si
            Fin si 																			//Hasta aca llega la comparacion entre los procesos para ver cual tiene prioridad para entrar y se intento realizar la 1er carga
						LS:= primLS
            carga_best_fit(LS) 													//Ahora que primLS apunta al proceso restante en cola de listo/suspendido se intenta hacer la carga del segundo proceso a mem pricipal
            Si carga_hecha = true entonces
              cant_proc_LS:=cant_proc_LS - 1
        			cant_proc_L:= cant_proc_L + 1
              Borrar proceso de lista de listos/suspendidos
            Fin si
          Sino
          	carga_best_fit(LS) 													//habia un solo proceso por lo que se intenta hacer la carga de dicho proceso a mem principal
            Si carga_hecha = true entonces
            	cant_proc_LS:=cant_proc_LS - 1
        			cant_proc_L:= cant_proc_L + 1
              Borrar proceso de lista de listos/suspendidos
            Fin si
          Fin si
        Fin si
      Fin si   	
      finDeCargaMem:= verdadero 												//Ya sea pq la memoria principal ya tiene 3 procesos, o pq la memoria secundaria esta vacia, o porque se realizaron/fallaron las diferentes cargas, pasamos a la siguiente etapa del codigo
   	Sino
      multiprogramacion:= cant_proc_L + cant_proc_LS 				//asigno la cantidad de procesos en listos y listos y susp. a "multiprogramacion"
      si (multiprogramacion < 5) entonces  									//Verificacion de multiprogramacion, si es menor a 5 entonces podemos ingresar mas procesos a memoria princip o secund
        Mientras (multiprogramacion < 5) hacer 
          si (cant_proc_L < 3) entonces 										//verifico que en la cola de listos hayan menos de 3 procesos 
            si (cant_proc_LS > 0) entonces 
              //swap in de LS a L        											 //paso un proceso de listos y susp. a listos.
              caraga_best_fit()
              Si carga_hecha = true entonces
              	Borrar proceso de lista de listos/suspendidos
              	cant_proc_LS:=cant_proc_LS - 1
        				cant_proc_L:= cant_proc_L + 1
              Fin si
               //cambiar estado a "listo"														//cambio el estado del proceso a "listo"
            sino 
              //Ingreso de N a L 																		//paso un proceso de nuevos a listos
              caraga_best_fit()                                 //la eliminacion del proceso no se hace en lista de LS sino que se hace en lista de nuevos, habria que modificar el procedimiento o hacer otro
              Si carga_hecha = true entonces
              	Borrar proceso de lista de nuevos
              	cant_proc_N:=cant_proc_N - 1
        				cant_proc_L:= cant_proc_L + 1
              Fin si
                
              //cambiar estado a "listo"
            fs
          sino 
            si (cant_proc_LS <2)  enonces 													//en caso de que la cola de listos este a tope (3 procesos), verifico que la cola de listos y sup tenga menos de 2 procesos.
              Ingreso de N a LS 															//paso un proceso de nuevos a listos y susp.
              cant_proc_N:=cant_proc_N - 1
        			cant_proc_LS:= cant_proc_L + 1
              //cambiar estado a "listo y susp."
            sino
            	finDeCargaMem:=verdadero
            fs
          fs
        fin mientras
      sino 																																		//si la multiprogramacion ya alcanzo su tope (5 procesos) entonces no podemos agregar nada a ninguna memoria por lo que seguimos con el analsisis
      	finDeCargaMem:= verdadero
      Fin si
      	si finDeCargaMem entonces 
         si (cant_proc_L <> 0) entonces 												// control de error par iteraciones donde la memoria principal esta vacias.
     																																			//al no estar vacia se sigue analizando con el algoritmo strf para determinar que proceso debe ejecutarse
          Para i:= 1 hasta 3 hacer 																									//se busca el prceso que tenga menor tiempo de interrupcion para mandarlo a ejecutarce 
            Si (*L.TI < LV) Entonces 
              *M. := *L 
              *M.Estado := "Ejecuctando"
              *M.Frag := (*M.Par - *L.TAM)
              L := *L.prox 
            Fin_ Si 
					Fin_Para 
          
          Si (*M.TI = 0) entonces 																					//Pregunta si termono el proceso, si termono se lo manda a la lista de terminados y se cambia su estado 
          	Procedimeinto mandar a terminados 
            *M.Estado := "Terminados" 
            Procedieminto eliminar 
          Sino 
            Procedimeinto Mostrar                                     //Muestra por pantalla la lista de como queda la de terminados y la de listos 
         	Fin_Si 	
        fs
        finDeCargaMem:= falso
        Tiempo_actual:= Tiempo_actual +1
        si (cant_proc_E = 0) entonces
        	band:= Verdadero
          si (cant_proc_L = 0) entonces               												//calculo estadisticas y muesrto informe final (tiempo de retorno y espera promedios. Cantidad de trabajos terminados por unidad de tiempo)
            Tiempo_Espera_prom: Tiempo_Espera_prom / cant_proc_E
            Tiempo_Retorno_prom: Tiempo_retorno_prom / cant_proc_E
            Rendimiento:= cant_proc_T / Tiempo_actual
          sino
            band:= falso 																											//Permitimos volver a empezar el ciclo pq no se termino de analizar todos los procesos
            retorno_listaN_vacia?:= true
          fs
        fs
      fs
    fs    
	Fin Mientras
  
  Ideas: DE MAURI
  	If (*N.TA == TA) 
      If (Tamaño Proceso > 250) entonces                                    //Pregunta si el tamaño de mmemoria es muy grande para entrar en las particiones 
        Print("El proceso", ID "es demasiado grande para ser ejecutado por lo tanto sera eliminado")
        Procediemiento Eliminar()
      else 
        If (Tamaño Proceso <= 50 and Band1 == True) Entonces 							//Pregunta si puede entrar en la particion N1, si entra en el proceso se incremente el contado Multiprogramacion 
          *L.Par1 := "Proceso" *E.ID *E.TAM 
          *L.Frag1 := (50 - *E.TAM) 
          Multiprogramacion:=  Multiprogramacion + 1
         Band1 = False 
        else 
          If (Tamaño Proceso <= 150 and Band2 == True) Entonces 				//Pregunta si puede entrar en la particion N2, si entra en el proceso se incremente el contado Multiprogramacion 
            *L.Par2 := "Proceso" *E.ID *E.TAM 
            *L.Frag2 := (150 - *E.TAM) 
            Multiprogramacion:=  Multiprogramacion + 1 
           	Band2 = False 
          else  																													//Pregunta si puede entrar en la particion N3, si entra en el proceso se incremente el contado Multiprogramacion 
            If (Tamaño Proceso <= 250 and Band3 == True) 
              *L.Par3 := "Proceso" *E.ID *E.TAM 
              *L.Frag3 := (250 - *E.TAM) 
              Multiprogramacion:=  Multiprogramacion + 1
              Band3 = False 
            FS
          FS
        FS 
      FS
    FS 
    
    Nuevo(LS)                                         //Cargo 2 procesos en lista de Listos Y suspendidos 
    LS = Prim 
    Prim = L 
    Multiprogramacion:=  Multiprogramacion + 1
    Nuevo(LS)
    L = *L.Prox
    *Prim.Prox =  LS
    *LS.Prox := nil
    LS := L
    Multiprogramacion:=  Multiprogramacion + 1
    
    
    If (Multiprogramacion == 5) 
    	Print("Espacios de memoria llenos")
    FS


    //Para calcular la fragmentacion interna vamos a tener que hacer el tamañp de la particion - tamaño del proceso que se encuentra en ella por lo que vamos a necesitar...
    //...una funcion que convierta el contenido de la particion (id de proceso en alfanumerico) a numero y asi buscar ese proceso en listo o listo y suspendido y obtener TAM.
